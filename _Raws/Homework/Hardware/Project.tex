\documentclass[12pt letter]{report}
\input{../template/preamble}
\input{../template/macros}
\input{../template/letterfonts}

\usepackage{karnaugh-map}
\usepackage{parskip}
\usepackage{graphicx}
\graphicspath{ {assets/} }
\title{\Huge{Group 12 Project}}
\author{\huge{Madiba Hudson-Quansah \& Ronelle Cudjoe}}
\date{}


\begin{document}
\maketitle
\newpage

\qs{}{
  Binary to Gray Code Converter \\
  Identify the bit pattern changes and derive an expression with justification.
}

\sol{
  The bit pattern changes from binary to gray code ensure that only one-bit changes between
  consecutive values. The most significant bit of the gray code ( $G_3G_3$) is the same as the binary
  most significant bit ($B_3B_3$), minimizing errors. Each subsequent gray bit is derived by XORing
  adjacent binary bits:
  \begin{align*}
    G_3 & = B_3             \\
    G_2 & = B_3 \oplus B_2  \\
    G_1 & = B_2 \oplus  B_1 \\
    G_0 & = B_1 \oplus B_0  \\
  \end{align*}
  The XOR operation ensures only one-bit transitions, providing a reliable and efficient method for
  encoding, particularly in applications where minimal changes reduce errors during transitions.

  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.5\textwidth]{1.jpeg}
    \end{center}
  \end{figure}
}

\qs{}{
  Gray Code to Binary Converter \\
  Identify the bit pattern changes and derive an expression with justification.
}

\sol{
  From our observation of the binary to gray code truth table these things are apparent:
  \begin{itemize}
    \item The most significant bit (MSB) in the binary representation stays the same in the gray code representation.
    \item Subsequent bits are derived by XORing the current gray code bit with the preceding binary bit, i.e, $B_1 = B_2 \oplus G_1$
  \end{itemize}
  This results in the expressions
  \begin{align*}
    B_3 & = G_3            \\
    B_2 & = B_3 \oplus G_2 \\
    B_1 & = B_2 \oplus G_1 \\
    B_0 & = B_1 \oplus G_1
  \end{align*}
  Where $B$ and $G$ are the bits of the binary and gray code number representation respectively.
  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.5\textwidth]{2.png}
    \end{center}
  \end{figure}
}

\qs{}{
  BCD to 7-segment Decoder.
}

\sol{
  \begin{enumerate}
  \item
  \begin{karnaugh-map}[4][4][1][$CD$][$AB$]
  \minterms{0,2,3,5,6,7,8,9,10,11,12,13,14,15}
  \maxterms{1,4}
  \implicant{12}{10}
  \implicant{3}{10}
  \implicantcorner[0,2,8,10]
  \implicant{5}{15}
  \draw[color=black, ultra thin] (0, 0) grid (4, 4);
  \end{karnaugh-map}


  \item
  \begin{karnaugh-map}[4][4][1][$CD$][$AB$]
  \minterms{0,1,2,3,4,7,8,9,10,11,12,15}
  \maxterms{5,6,13,14}
  \implicant{8}{10}
  \implicant{3}{11}
  \implicant{0}{2}
  \implicant{0}{8}
  \draw[color=black, ultra thin] (0, 0) grid (4, 4);
  \end{karnaugh-map}


  \item
  \begin{karnaugh-map}[4][4][1][$CD$][$AB$]
  \minterms{0,1,2,4,5,6,7,8,9,11,12,13,14,15}
  \maxterms{3,10}
  \implicant{5}{15}
  \implicant{13}{11}
  \implicant{7}{14}
  \implicant{2}{6}
  \implicant{0}{9}
  \draw[color=black, ultra thin] (0, 0) grid (4, 4);
  \end{karnaugh-map}


  \item
  \begin{karnaugh-map}[4][4][1][$CD$][$AB$]
  \minterms{0,2,3,5,6,8,9,10,11,12,13,14,15}
  \maxterms{1,4,7}
  \implicantcorner[0,2,8,10]
  \implicant{3}{2}
  \implicant{12}{10}
  \implicant{2}{10}
  \implicant{5}{13}
  \implicant{14}{10}
  \draw[color=black, ultra thin] (0, 0) grid (4, 4);
  \end{karnaugh-map}


  \item
  \begin{karnaugh-map}[4][4][1][$CD$][$AB$]
  \minterms{0,2,6,8,10,14}
  \maxterms{1,3,4,5,7,9,11,12,13,15}
  \implicantcorner[0,2,8,10]
  \implicant{2}{10}
  \draw[color=black, ultra thin] (0, 0) grid (4, 4);
  \end{karnaugh-map}


  \item
  \begin{karnaugh-map}[4][4][1][$CD$][$AB$]
  \minterms{0,2,3,5,6,7,8,9,10,11,12,13,14,15}
  \maxterms{1,4}
  \implicantcorner[0,2,8,10]
  \implicant{12}{10}
  \implicant{5}{15}
  \implicant{3}{10}
  \draw[color=black, ultra thin] (0, 0) grid (4, 4);
  \end{karnaugh-map}


  \item
  \begin{karnaugh-map}[4][4][1][$CD$][$AB$]
  \minterms{2,3,4,5,6,8,9,10,11,12,13,14,15}
  \maxterms{0,1,7}
  \implicant{4}{13}
  \implicant{12}{10}
  \implicant{2}{10}
  \implicantedge{3}{2}{11}{10}
  \draw[color=black, ultra thin] (0, 0) grid (4, 4);
  \end{karnaugh-map}
  \end{enumerate}
  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.5\textwidth]{3_1.jpeg}
    \end{center}
  \end{figure}

  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.5\textwidth]{3_2.jpeg}
    \end{center}
  \end{figure}

}

\qs{}{
  Ashesi Vending Machine
}

\sol{
  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.5\textwidth]{4.jpeg}
    \end{center}
  \end{figure}
}

\qs{}{
  Traffic Light System
}

\sol{
  \begin{figure}[H]
    \begin{center}
      \includegraphics[width=0.7\textwidth]{light.jpeg}
    \end{center}
  \end{figure}
}

\section*{Reflection Questions}

\qs{}{
  What challenges did you encounter during the design of the Binary to Gray Code Converter, and how did you overcome them?
}

\sol{
  The need to understand and implement the specific conversion logic between the two codes, proved challenging and overcoming it involved breaking the problem into manageable steps, using bitwise operations, and designing a modular system that can handle varying bit lengths.

}

\qs{}{
  What considerations influenced the choice of error-checking mechanisms in the Gray Code to Binary Converter?
}

\sol{
  In verifying the Gray Code to Binary Converter, we used logisim's built-in test vector feature to validate the converter's
  functionality against the provided truth table.
}

\qs{}{
  How did you define the mapping between BCD inputs and 7-segment display outputs in the BCD to 7-segment Decoder?
}

\sol{
  The mapping between BCD inputs and 7-segment display defines how a 4-bit binary input (representing digits 0-9) controls the segments of a 7-segment display. Each BCD input corresponds to a specific 7-bit output, where each bit controls one segment of the display (labeled a-g). For example, a BCD input of 0000 (decimal 0) turns on all segments except 'g', displaying the digit '0' on the 7-segment display.
}

\qs{}{
  What strategies did you employ to simulate and validate the functionality of the Ashesi Vending Machine?
}

\sol{
  We broke down the system into subsystems like input, logic, and output, modelling each part separately and testing various input scenarios, including normal and edge cases to ensure the machine handles all possible user interactions correctly.
}

\qs{}{
  How did you prioritize optimization efforts in each module to ensure efficient resource utilization?

}

\sol{
  We focused on minimizing the number of components, such as logic gates and memory elements, to reduce circuit complexity and resource usage. Simplifying control logic and improving decision-making speed to ensure efficient operation and fast response times.
}

\qs{}{
  What insights did you gain from comparing different conversion algorithms in the Binary to Gray Code and Gray Code to Binary converters?

}

\sol{

  We found that there were two main ways to convert between binary and gray code. The first was to represent each bit as
  an output of a boolean expression and find the SOP expression for each bit. The second was based on intuition and
  inspection of the truth table, which produced a XOR expression for each bit. The XOR expression was more intuitive and
  easier to derive, making it the preferred method for conversion.
}

\qs{}{
  How did you address potential edge cases or corner scenarios in the design of each module?

}

\sol{
  To address edge cases, we implemented an in-built test vector that detects invalid inputs by checking the systemâ€™s behavior against the truth table. This test logic simulates a variety of scenarios, ensuring that the system provides appropriate error handling and feedback under both normal and exceptional conditions. By testing edge cases and verifying correct responses, the system can handle unexpected inputs or failures while maintaining reliable operation.
}

\qs{}{
  In what ways did this project enhance your understanding of digital circuit design principles and the practical applications of Logisim Evolution?

}

\sol{
  It has shown me the importance of simulation in digital circuit design, such as modeling a traffic light system, which helped me understand how timing, sequencing, and logic work in real-world applications. This project enhanced my understanding of digital circuit design by demonstrating how simulations allow for testing and refining designs before physical implementation, bridging theory with practical applications using Logisim Evolution.
}


\end{document}
