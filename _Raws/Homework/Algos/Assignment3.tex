\documentclass[12pt letter]{report}
\input{../template/preamble}
\input{../template/macros}
\input{../template/letterfonts}

\newcommand{\qlabelhook}{\framebox}
\newcommand{\qleafhook}{\framebox}

\usepackage{qtree}
\usepackage{parskip}
\title{\Huge{Assignment 3}}
\author{\huge{Madiba Hudson-Quansah}}
\date{}


\begin{document}
\maketitle
\newpage

\qs{}{
  Apply quicksort to sort the list Q,U,I,C,K,S,O,R,T in alphabetical order. Draw the tree of the recursive calls made.
}

\sol{
\Tree[.{ $l = 0, r = 8$ \\ $s = 4$} [.{ $l = 0, r = 3$ \\ $s = 1$} [.{ $l =0, r =0$ \\ $s =0$} ]
  [.{ $l =2, r =3$ \\ $s =2$} [.{ $l =3, r =3$ \\ $s =3$} ]]]
[.{ $l = 5, r = 8$ \\ $s = 8$}
[.{ $l =5, r =7$ \\ $s =6$} [.{ $l = 5, r =5$ \\ $s =5$} ] [.{ $l =7, r =7$ \\ $s =7$} !{\qbalance} ] !{\qbalance} ]
!{\qbalance} ] ] \\

Where the first element in the subarray is chosen as the pivot and where $s$ and $r $ are the start and end index of the partitioned subarray respectively, and $s$ is the index of the
pivot in the final sorted list.
So $s = 5, r = 8, s= 8$ means for the subarray starting from index $5$ to $8$ inclusive the pivot ends up at the index
$8$ in the final list.
}

\qs{}{
  \begin{enumerate}
    \item   Apply the bottom-up dynamic programming algorithm to the following instance of the knapsack problem
    \item How many different optimal subsets does the instance of part (a) have?
    \item In general, how can we use the table generated by the dynamic programming algorithm to tell whether there is more than one optimal subset for the knapsack problem’s instance?
    \item Instead of computing values in a bottom-up way, suppose we apply the memory function method to the instance of the knapsack problem given in part (a). Indicate the entries of the dynamic programming table that are (i) never computed by the memory function method, (ii) retrieved without a re-computation.

  \end{enumerate}
}

\sol{

  \begin{enumerate}
    \item The recurrence relation of the knapsack problem is:
          \[
            F \left( i, j \right) = \begin{cases}
              \text{max} \left\{ F \left( i - 1, j \right), v_i + F \left( i - 1, j - w_i \right)   \right\} & \text{if } j - w_i
              \geq 0                                                                                                                  \\
              F \left( i - 1, j \right)                                                                      & \text{if } j - w_i < 0
            \end{cases}
          \]
          Where $i$ is the index of the $i$th item in consideration, $j$ is the capacity of the knapsack, $v_i$ is the value of
          the $i$th item, and $w_i$ is the weight of the $i$th item.
          For the base cases $F \left( 0, j \right) = 0 $  for $j \geq 0$ and $F \left( i, 0 \right) = 0 $ for $i \geq 0$
          This gives us the table
          \begin{table}[H]
            \begin{center}
              \begin{tabular}{c|c c c c c c c}
                $i$ & 0 & 1  & 2  & 3  & 4  & 5  & 6            \\ [0.5ex]
                \hline
                0   & 0 & 0  & 0  & 0  & 0  & 0  & 0            \\
                1   & 0 & 0  & 0  & 25 & 25 & 25 & 25           \\
                2   & 0 & 0  & 20 & 25 & 25 & 45 & 45           \\
                3   & 0 & 15 & 20 & 35 & 40 & 45 & 60           \\
                4   & 0 & 15 & 20 & 35 & 40 & 55 & 60           \\
                5   & 0 & 15 & 20 & 35 & 40 & 55 & $\mbold{65}$ \\
              \end{tabular}
            \end{center}
          \end{table}
    \item  There is only one optimal subset.
    \item By tracing back the table from the bottom right corner to the top left corner, if there is more than one path
          to the top left of the table, then there is more than one optimal subset.
    \item
  \end{enumerate}
}

\qs{}{
  Apply Warshall’s algorithm to find the transitive closure of the digraph defined by the following adjacency matrix:
  \[
    \begin{pmatrix}
      0 & 0 & 0 & 1 \\
      0 & 0 & 1 & 0 \\
      0 & 0 & 0 & 1 \\
      0 & 0 & 0 & 0 \\
    \end{pmatrix}
  \]
}

\sol{
  \begin{align*}
    R^{(0)} & =     \begin{bmatrix}
                    0 & 0 & 0 & 1 \\
                    0 & 0 & 1 & 0 \\
                    0 & 0 & 0 & 1 \\
                    0 & 0 & 0 & 0 \\
                  \end{bmatrix}
    \\
    R^{(1)} & =
    \begin{bmatrix}
      0 & 0 & 0 & 1 \\
      0 & 0 & 1 & 0 \\
      0 & 0 & 0 & 1 \\
      0 & 0 & 0 & 0 \\
    \end{bmatrix}
    \\
    R^{(2)} & =
    \begin{bmatrix}
      0 & 0 & 0 & 1 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 0 & 1 \\
      0 & 0 & 0 & 0 \\
    \end{bmatrix}
    \\
    R^{(3)} & =
    \begin{bmatrix}
      0 & 0 & 0 & 1 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 0 & 1 \\
      0 & 0 & 0 & 0 \\
    \end{bmatrix}
    \\
    R^{(4)} & =
    \begin{bmatrix}
      0 & 0 & 0 & 1 \\
      0 & 0 & 1 & 1 \\
      0 & 0 & 0 & 1 \\
      0 & 0 & 0 & 0 \\
    \end{bmatrix}
    \\
  \end{align*}
}

\qs{}{
  Design a divide-and-conquer algorithm for computing the number of levels in a binary tree. (In particular, the algorithm must return 0 and 1 for the empty and single-node trees, respectively.) What is the time efficiency class of your algorithm?
}

\sol{
  \begin{algorithm}[H]
    \caption{NumLevels $ \left( R \right) $}
    \Comment{}\\
    \Comment{Calculates the number of levels in a binary tree with root $R$} \\
    \Comment{Input: The root of the binary tree $R$} \\
    \Comment{Output: The number of levels in the binary tree} \\
    \begin{algorithmic}[1]
      \State $h \gets 0$
      \For{ each child $c$ of $R$}
      \State $h \gets $ max $\left( h, \text{NumLevels} \left( c \right) + 1 \right)$
      \EndFor
      \State \Return $h$
    \end{algorithmic}
  \end{algorithm}
  The time efficiency class of the algorithm is $O \left( n \right)$ where $n$ is the number of nodes in the binary tree.
}




\end{document}
