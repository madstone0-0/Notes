\documentclass[12pt letter]{report}
\input{./template/preamble}
\input{./template/macros}
\input{./template/letterfonts}

\title{\Huge{Software and the Nature of Software}}
\author{\huge{Madiba Hudson-Quansah}}
\date{}
\usepackage{parskip}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\begin{document}
\maketitle
\newpage
\pdfbookmark[section]{\contentsname}{too}
\tableofcontents
\pagebreak

\chapter{The Nature of Software}

\section{Defining Software}

\dfn{Software}{
  Software is instructions, that when executed provide desired features, function and performance; data structures
  that enable the programs to adequately manipulate information in both hard copy and virtual forms that describes the
  operation and use of the programs.
}

The characteristics of software:
\begin{description}
  \item[Software is developed or engineered; it is not manufactured in the classical sense] - There may exist
        similarities between the development and manufacture of software and hardware respectively, like quality through
        design, but the manufacturing phase for hardware can introduce quality problems that are non-existent in software
        contexts.
  \item[Software doesn't "wear out"] - Usually hardware exhibits relatively high failure rates early in it's life, and
        corrected and the failure rate drops to a steady-state level for some period of time. Software does not behave
        the same, with decreasing failure rate with spikes when when defects are discovered as changes are made.
  \item[Although the industry is moving towards component-based construction, most software continues to be custom built] -
        As the field matures more and more best practices are codified and a set of standard design
        components are established. This allows the engineer to focus on the truly innovative elements of a design.
\end{description}

\section{Software Application Domains}
\begin{description}
  \item[System Software]  - A collection of programs written to service other programs. Characterized by heavy
        interaction with computer hardware, heavy usage by multiple users, concurrent operations that require scheduling,
        complex data structures, and multiple external interfaces.
  \item[Application Software] - Stand-alone programs that solve a specific business need. Process business or technical
        data in a way that facilities business operations or management/technical decision making.
  \item[Engineering / Scientific Software] - Characterized by number crunching algorithms, which application areas
        ranging from astronomy to volcanology, from automotive stress analysis to space shuttle orbital dynamics, and from
        molecular biology to automated manufacturing.
  \item[Embedded software] - Resides within a product or system and is used to implement and control features and
        functions for the end user and the system itself.
  \item[Product-line software] - Designed to provide a specific capability for use by many different customers.
  \item[Web Applications] - A set of linked hypertext files that represent information using text and graphics.
  \item[Artificial Intelligence software] - Makes use of non-numerical algorithms to solve complex problems that re not
        amenable to computation or straightforward analysis.
\end{description}

\chapter{Software Engineering}

\dfn{Software Engineering}{
  The application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of
  software; that is the application of engineering to software.
}

Software Engineering, like an onion, has layers and with any engineering approach has it's foundation in an
organizational commitment to quality.
\begin{description}
  \item[Process Layer]  - The foundation of software engineering, enables rational and timely development of computer
        software by defining a framework that must be established for effective delivery of software engineering
        technology.
  \item[Method Layer] - Provide technical descriptions and guides for building software, encompassing a broad array of
        tasks including communication, requirement analysis, design modelling, program construction, testing and support.
  \item[Tools Layer] - Provide automated or semi-automated support for the process and the methods.
\end{description}

\section{The Software Process}
\dfn{Process}{
  A collection of activities, actions, and tasks that are performed when some work product is to be created
}

\dfn{Process Framework}{
  Establishes the foundation for a complete software process by identifying a small number of framework activities that
  are applicable to all software projects regardless of size or complexity. The process framework details a set of umbrella activities also applicable across the software process
}

A generic process framework encompasses:
\begin{description}
  \item[Communication] - Interaction with stakeholders to understand objectives for a project and to gather requirements that help define features and functions
  \item[PLanning] - Describes the scope of the project, i.e. technical tasks to be conducted, the risks involved, the resources required, deliverables and a work schedule.
  \item[Modelling] - A representation of the software that can be used to understand software requirements and validate design decisions.
  \item[Construction] - Code generation and testing.
  \item[Deployment] - The software is delivered to the customer and evaluated, with feedback provided to the developers.
\end{description}

\dfn{Umbrella Activities }{
  Activities used throughout the software development process used mange and control process, quality, changes and risk.
}

Common umbrella activities include:
\begin{itemize}
  \item Software project tracking and control - Assess progress against the project plan and take necessary measures to keep on schedule.
  \item Risk Management - Assess risks that may affect the outcome of the project
  \item Technical reviews - Assess work products in an effort to identify and correct errors and defects.
  \item Reuseability Management - Defines criteria for work product reuse and establishes mechanisms to achieve reusable components.
\end{itemize}

\section{Software Engineering Practice}
\subsection{The Essence of Practice}
Polya's idea of the problem solving practice
\begin{description}
  \item[Understand the Problem] - Identify stakeholders, data, functions, and features. Reduce the problem to a set of subproblems. Attempt to graphically represent the problem
  \item[Plan a solution] - Identify patterns recognizable in a possible solution. Try and relate the problem to similar solved problems and identify reusable elements. Identify reusable solutions for subproblems. Attempt to create a design model
  \item[Carry out the plan] - Translate the design model into a program. Test the program to ensure it meets the requirements
  \item[Examine the result for accuracy] - Implement a testing strategy. Validate the stakeholder requirements.
\end{description}

\subsection{General Principles}
Hooker's principles of software engineering serve as important guidelines for software engineering practice:
\begin{description}
  \item[The Reason It All Exists]  - Software exists to provide value to stakeholders. All decisions must be validated against this principle, i
  \item[Keep it Simple Stupid (KISS)] - All design must be as simple as possible, but no simpler. Strive for simplicity over needless complexity as this allows for an easily understood system that is easy to maintain and improve.
  \item[Maintain the Vision] - A clear vision is essential to the success of a software project. Maintain the architectural vision throughout the project to prevent inconsistencies.
  \item[What You Produce, Others Will Consume] - Always specify, design and implement knowing someone else will have to understand what you are doing.
  \item[Be Open to the Future] - Never design yourself into a corner. Design systems that are flexible and solve a general problem, allowing reuse and extension.
  \item[Plan Ahead for Reuse] - Planning ahead for reuse reduces the cost and increases the value of both the reusable components and the systems into which they are incorporated.
  \item[Think!] - Placing clear, complete thought before action almost always produces better results. Be able to recognize when you do not know something and seek an answer.

\end{description}


\end{document}
