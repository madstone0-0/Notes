\documentclass[12pt letter]{report}
\input{./template/preamble}
\input{./template/macros}
\input{./template/letterfonts}

\title{\Huge{Introduction to Databases}}
\author{\huge{Madiba Hudson-Quansah}}
\date{}
\usepackage{parskip}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\begin{document}
\maketitle
\newpage
\pdfbookmark[section]{\contentsname}{too}
\tableofcontents
\pagebreak

\chapter{Introduction}


\section{Uses of Databases}

\begin{description}
  \item[Retail]  - Department stores, supermarkets, mail order companies, etc.
  \item[Social Media] - Store information about users, their friends, and their activities.
\end{description}

\section{File Based Systems}

\dfn{File-Based Approach}{
  A collection of application programs that perform services for the end-users, where each program defines and manages
  its own data
}

\subsection{Disadvantages of File-Based Systems}

\begin{itemize}
  \item Space intensive
  \item Data redundancy / Duplication - Due to each program having and controlling its own data, if data is needed by multiple programs, it must be duplicated.
  \item Separation and isolation of data - When data is scattered across different files, it becomes difficult to
        access data that should be available.
  \item Data Dependence / Program-Data Dependence - The inherent relationship between the application program and the data it uses. This leads
        to:
        \begin{itemize}
          \item Difficulty in updating data
        \end{itemize}
  \item Incompatible file formats.
  \item Fixed Queries / Proliferation of application programs - Due to the nature of file-based systems creating new
        queries is difficult as a developer would have to write the new queries into the program.
  \item Difficulty in accessing data
  \item Inconsistent data
\end{itemize}


\section{Database Management Systems (DBMS)}
\subsection{Database}
\dfn{Database}{
  A \textit{shared} collection of \textit{logically} related data, and descriptions of this data, designed to meet the
  information needs of an organization. / A set of named relations.
}

\dfn{System Catalogue / Data Dictionary}{
  A description of the data in the database (metadata).
}

\dfn{Entity / Record}{
  A distinct real world object that is to be represented in a database / Row.
}

\dfn{Attribute}{
  A property that describes an entity. / Column.
}

\dfn{Relationship}{
  An association between entities. / Table
}

\subsection{Database Management System (DBMS)}
\dfn{Database Management System (DBMS)}{
  A software system that enables users to define, create, maintain, and control access to the database. A DBMS usually
  provides the following functions:
  \begin{description}
    \item[Data Definition Language (DDL)] - Allows users to define a database by describing the data types, structures,
          and constraints on the data to be stored in the database.
    \item[Data Manipulation Language (DML)] - Allows users to insert, update, delete, and retrieve data from the
          database. The DML, then provides a \textbf{query language}, which is used for inquiry and reporting.
    \item[Controlled Access] -
          \begin{itemize}
            \item Ensures that only authorized users can access the database,
            \item Ensures the consistence of the stored data is maintained
            \item Manages concurrent access to the database
            \item Provides a recovery system to ensure consistency of data in the presence of system failures.
          \end{itemize}
  \end{description}
}

\subsubsection{Properties of a DBMS}

\begin{description}
  \item[Massive] Be able to manage large amounts of data.
  \item[Persistence]  Data should be available even after the application has been closed.
  \item[Safe]  Hardware and software failures should not cause data loss.
  \item[Multi-user / Concurrent] Multiple users should be able to access the database at the same time>
  \item[Convenient] Be able to declaratively specify queries and operations.
  \item[Efficient] Be able to perform operations and process queries quickly.
  \item[Reliable] Be able to recover from failures.
\end{description}

\subsubsection{Difference between File-Based Systems and DBMS}

\nparagraph{The Self-Describing Nature of a Database System}

The database system contains the complete definition of the database structure and constraints. This definition is

\nparagraph{Multiple Views of Data}

Each user may see a different view of the database, and the DBMS must control the access of these users to the database.

\nparagraph{The Concurrent Access to the Data}

Each user must be able to access the data concurrently, and the DBMS must include concurrency control techniques to ensure that the user's operations are correctly synchronized.


\dfn{Database System}{
  A DBMS together with the database itself.
}

\section{(Database) Application Programs}

\dfn{(Database) Application Programs}{
  Programs that interact with the DBMS to access the database, using the DBMS's DML and query language.
}

\subsection{Views}

\dfn{View / View Mechanism}{
  A subset of the database, defined using queries. Views provide an abstracted view of the database, hiding irrelevant
  information from the end-user.
}

Views not only serve as an abstraction layer but also provide:

\begin{description}
  \item[A Level of Security] - Views can be used to exclude sensitive data to unauthorized parties.
  \item[Customization] - Views can be used to better present data for end-users
  \item[Consistency] - Views can be used to preserve the state of the database even though the underlying data may have
        changed.
\end{description}

\section{Comparison of File-Based Systems and DBMS}

\subsection{Advantages of Using the DBMS Approach}

\begin{itemize}
  \item Control of data redundancy - Data is stored in a central location, and is not duplicated unnecessarily across multiple
        programs. As some data will need to be duplicated for various reasons such as performance.
  \item Data Consistency - If a data item is stored only once in the database, an update to it will reflect in all
        places it is used, ensuring consistency.
  \item Data Sharing - Data can be shared across departments, and applications without the need for duplication.
  \item Improved Data Integrity - Database integrity refers to the validity and consistency of stored data. Integrity is
        defined in terms of constraints, which are consistency rules that the database is not allowed to violate. With DBMS,
        the Database Admin can define constraints that the DBMS will enforce.
  \item Economy of Scale - The cost of developing and maintaining the database is spread over all the applications that
        use the database.
\end{itemize}

\subsection{Disadvantages of Using the DBMS Approach}

\begin{itemize}
  \item Complexity - The DBMS is a complex piece of software, and as such, it requires a high level of expertise to
        manage.
  \item Size - The complexity and breadth of functionality usually makes the DBMS large and resource-intensive.
  \item Cost of DBMS - The cost of acquiring a DBMS can be high.
  \item Additional hardware costs - The disk storage requirements of a DBMS and the database may require the purchase of
        additional storage space.
  \item Higher impact of a failure - The centralization of resources increases the vulnerability of the system to
        failure as a failure will affect all the applications that use the database which due to centralization, is a lot.
  \item Performance - The DBMS may not be as efficient as a custom-built file-based system.
\end{itemize}

\section{Components of a Database System}

\begin{itemize}
  \item Users - Application programs, DBA, End-users
  \item Software - Controls the organization, storage, management and retrieval of data.
  \item Hardware - The physical devices used to store and process the data.
  \item Data - The data to be stored in the database.
\end{itemize}


\chapter{Database System Environment}

\subsection{Database Users / Roles}

\begin{description}
  \item[Database Administrators] Responsible for authorizing access to the database for coordinating and monitoring its
        use. Acquiring software and hardware resources, controlling its use, and monitoring efficiency of operations.
  \item[Data Administrators] Responsible for the management of the organization's data resources, including the
        database planning, development, maintenance of standards, polices, and procedures.
  \item [Database Designers] Responsible for defining the content structure, constraints, and functions or transactions of
        the database. Database designers can be split into two categories:
        \begin{itemize}
          \item Logical Database Designers - Focus on the logical structure of the database, i.e. the constraints on
                data to be stored in the database (business rules).
          \item Physical Database Designers - Focuses on how the logical database is to be actually implemented. This
                involves:
                \begin{itemize}
                  \item Mapping the logical structure to a set of tables and integrity constraints
                  \item Selecting storage structures and access methods
                  \item Designing security  measures required on the data.
                \end{itemize}
        \end{itemize}
  \item[Application Developers] Responsible for developing the application programs that provide required
        functionality for the end users, using the implemented database.
  \item[End Users] Clients of the database, which has been designed and implemented to serve their information needs.
        The can be classified according to the way the interact with the system.
        \begin{itemize}
          \item Naive Users - Unsophisticated users who interact with the system through application programs.
          \item Casual - Users who access the database occasionally, and may not be familiar with the system.
          \item Sophisticated - Users who interact with the system regularly and are familiar with the structure of the
                database and the facilities provided by the DBMS.
          \item Stand-alone - Users who maintain personal databases using ready-to-use packaged applications.
        \end{itemize}
\end{description}


\section{ANSI-SPARC Three-Level Architecture}

\dfn{ANSI-SPARC Three-Level Architecture}{
  American National Standards Institute (ANSI) Standards Planning and Requirements Committee (SPARC). A database architecture that separates the user's view of the database from the way the data is physically stored.
}

This architecture is based on the idea that a database system should be divided into three levels of abstraction:
\begin{itemize}
  \item External Level
  \item Conceptual Level
  \item Internal Level
\end{itemize}

\subsection{External Level}

\dfn{External Level}{
  The user's view of the database. Describes the part of the database that is relevant to the user.
}

This level consists of a number of external views of the database. Each external view includes only the entities,
attributes and relationships that are relevant to a particular user group.

\subsection{Conceptual Level}

\dfn{Conceptual Level}{
  The community view of the database. Describes what data is stored in the database and the relationships between the data.
}

This level contains the logical structure of the database as seen by the Database Administrator, i.e., the complete view
of the database without considering implementation details. The conceptual level represents:
\begin{itemize}
  \item All entities, attributes, and relationships
  \item Data integrity constraints
  \item Semantic information about the data
  \item Security information.
\end{itemize}
"

\subsection{Internal Level}

\dfn{Internal Level}{
  The physical representation of the database on the computer. Describes how the data is stored in the database.
}

\begin{itemize}
  \item Storage space allocation of data and indexes
  \item Record description for storage
  \item Record placement (pointers)
  \item Data compression and encryption techniques
\end{itemize}


\subsection{Data Independence}
\subsubsection{Logical Data Independence}
\dfn{Logical Data Independence}{
  Possibility for addition/removal of new entities, attributes or relationships. Indicates that the conceptual schema
  can be changed without affecting the existing external schemas.
}

This mainly affects the conceptual and external levels of the database, enabling a form of data abstraction from the
external views and the conceptual structure of the database.

\subsubsection{Physical Data Independence}
\dfn{Physical Data Independence}{
  Possibility for changes to storage structures. Indicates that the physical storage structures or devices could be
  changed without affecting conceptual schema.
}

This mainly affects the conceptual and internal levels of the database, decoupling the conceptual description of the
database from the actual physical implementation of the database.


\section{Database Languages}

\dfn{Database Languages}{
  A language that enables the user to create and maintain the database and provide ways to access and manipulate the
  data stored in the database.
}

\begin{itemize}
  \item Data Definition Language (DDL)
  \item Data Manipulation Language (DML)
\end{itemize}


\subsection{Data Definition Language (DDL)}

\dfn{Data Definition Language}{
  A language used to define and name, entities, their attributes, and relationships required for the application, along
  with integrity constraints.
}

Database schema is specified by a set of definitions defined in a Data Definition Language. The result of statements
made in a DDL is a set of tables stored in the system catalogue. The system catalogue couples the definition of these
objects to metadata which makes it easier to access and manage the objects. This metadata includes definitions of
records, data items, and other objects of interest.

\subsection{Data Manipulation Language (DML)}
\dfn{Data Manipulation Language}{
  A language that provides a set of operations to support the basic data manipulation operations on data in the
  database.
}
These operations include:
\begin{itemize}
  \item Insertion
  \item Retrieval
  \item Modification
  \item Deletion
\end{itemize}

The part of the DML that handles retrieval is called a query language. A query language differs from the whole DML by
their underlying retrieval constructs.

\dfn{Query Language}{
  High level special-purpose language used to satisfy diverse requests for the retrieval of data held in a database.
}

There are two types of DML:
\begin{itemize}
  \item Procedural
  \item Non-procedural
\end{itemize}
With the main difference being that Procedural languages specify how the output of a DML statement is to be obtained but
Non-procedural DMLs describe only what data is to be obtained.

\subsubsection{Procedural DMLs}
\dfn{Procedural DMLs}{
  A language that allows the user to tell the system what data is needed and exactly how to obtain the data
}

This means the user must express all the data access operations that are to be used by calling the corresponding
procedures obtaining the required output. Typically Procedural DMLs process each record individually basing the next
record it processes on the result of processing the previous record. This chain of retrievals continues until the data
requested has been gathered.

\subsubsection{Non-Procedural DMLs}

\dfn{Non-Procedural DMLs}{
  A language that allows the user to state what data is needed rather than how it is to be retrieved.
}

The DBMS translates the DML statement into procedures that manipulate the required sets of data.

\section{Data Models}

\dfn{Data Model}{
  An integrated collection of concepts for describing and manipulation of data. The data model provides the
  necessary means to achieve data abstraction, which is the process of hiding the low-level details of the database
  and showing only the relevant data to the user.
}
A data model comprises of three components:
\begin{description}
  \item[A Structural Part] - Consisting of a set of rules according to which databases can be constructed.
  \item[A Manipulative Part] - Defining the types of operations that are allowed on the data.
  \item[A Set of Integerity Constraints] - Ensures that the data is accurate.
\end{description}

Following the ANSI-SPARC architecture, we can identify three related data models:
\begin{itemize}
  \item An external data model / Universe of Discourse - To represent each user's view of the organization.
  \item A conceptual data model - To represent the logical view that is DBMS-independent.
  \item An internal data model - To represent the conceptual schema in a way that can be understood by the DBMS.

\end{itemize}

There are three main categories of data models:
\begin{itemize}
  \item Object-Based
  \item Record-Based
  \item Physical Data Model
\end{itemize}

\subsection{Object-Based Data Model}

These categories of model use concepts such as entities, attributes, and relationships to represent data. In this model an
\textit{entity} is a representation of a distinct real world object we want to include in the database, an
\textit{attribute} is a property that describes some aspect of an entity, a \textit{relationship} is an association
between entities. Some of the most common object-based data models include:
\begin{itemize}
  \item Entity-Relationship
  \item Semantic
  \item Functional
  \item Object-Oriented
\end{itemize}

\subsection{Record-Based Data Model}

These models are based on the concept of a record, which is a collection of fields, each of which contains one data
item. There are three principal types of record-based logical data model:
\begin{itemize}
  \item Relational Data Model
  \item Network Data Model
  \item Hierarchical Data Model.
\end{itemize}

\subsection{Physical Data Model}


\section{The Relational Model}

\subsection{Terminology}
\subsubsection{Database}
\dfn{Database}{
  A set of named relations.
}

\subsubsection{Relation}
\dfn{Relation / Table}{
  A table in a relational database.
}

\subsubsection{Attribute}
\dfn{Attribute}{
  A column in a table. Each relation has a named set of attributes.
}

\subsubsection{Tuple}
\dfn{Tuple}{
  A row in a table. Each tuple has a value for each attribute.
}

\subsubsection{Type}
\dfn{Type / Domain}{
  A description of the types of operations and values an attribute can have.
}

\subsubsection{Schema}
\dfn{Schema}{
  A structural description of relations in a database / A structural description of the tables in a database. A database
  differs from a database by the fact that a database is the implementation of the schema.
}

\subsubsection{Instance}
\dfn{Instance}{
  The actual data in a database at a particular point in time.
}

\subsubsection{Null values}
\dfn{Null}{
  Unknown / Undefined
}

\subsubsection{Key}
\dfn{Key}{
  An attribute unique to each tuple, used to differentiate entities / tuples.
}

\section{Software Architecture}

\dfn{Presentation Layer}{
  Medium of access.
}

\dfn{Application Layer}{
  Software that is accessed by the presentation layer.
}

\dfn{Database Layer}{
  The database
}

\nt{
  Machine means server.
}

\begin{itemize}
  \item One-Tier architecture -  Presentation layer , Application layer , Database layer on the same machine.
  \item  Two-Tier architecture - Database tier (Application and Database layers) on one machine and client tier
        (Presentation layer) on another.
  \item Three-Tier architecture - Each layer on its own machine
  \item N-Tier architecture - Multiple instances of tiers using replication procedures and load balancing.
\end{itemize}


\chapter{Relational Algebra and Relational Calculus}

\section{The Relational Algebra}

\nt{
  A relation is a table!
}

\dfn{Relational Algebra }{
  A theoretical language with operations that work on one or more relations to define another relation without changing
  the original relation. Thus both the input and output of the relational algebra are relations. This allows operation
  nesting and chaining. This property is known as \textbf{Closure}.
}

\subsection{Unary Operations}

\dfn{Unary Operations}{
  Operations that work on a single relation.
}

There are two types of unary operations:
\begin{itemize}
  \item  Selection / Restriction
  \item Projection
\end{itemize}

\subsubsection{Selection}

\dfn{Selection}{
  Works on a single relation $R$, and defines a relation that contains only those tuples of $R$ that satisfy the
  specified condition called a predicate. The selection operation is denoted by:
  \[
    \sigma_{\text{predicate}}\left( R \right)
  \]
  Where $R$ is the relation and
  the predicate is the condition that must be satisfied.
}

\qs{}{
  List all staff that earn more than 1000.
}

\sol{
  Therefore the selection operation is:
  \[
    \sigma_{\text{salary} > 1000} \left( \text{Staff} \right)
  \]
  And in SQL this would be:
  \begin{lstlisting}[language=SQL]
    SELECT * FROM Staff WHERE salary > 1000;
    \end{lstlisting}
}

\subsubsection{Projection}

\dfn{Projection}{

}



\section{Defining Schemas}

\subsection{Create Table}
In the SQL DDL, the \lstinline{CREATE TABLE} statement is used to create a new table. Relations created through this command are
base relations

\dfn{Base Table / Base Relation}{
  A table not derived from any other table.
}

To create a view using SQL the \lstinline{CREATE VIEW} statement is used.

\dfn{Virtual Table / Virtual Relation / View }{
  A table derived from other tables.
}



\end{document}
